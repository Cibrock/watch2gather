{"ast":null,"code":"import React from 'react';\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n/**\r\n * Copied from fbjs is-shallow-equal\r\n */\n\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\n\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n/**\r\n * Performs equality by iterating through keys on an object and returning false\r\n * when any key has values which are not strictly equal between the arguments.\r\n * Returns true when the values of all keys are strictly equal.\r\n */\n\n\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Special symbol which might be used to delete properties\r\n * from an object calling [StateMethods.set](#set) or [StateMethods.merge](#merge).\r\n *\r\n * [Learn more...](https://hookstate.js.org/docs/nested-state#deleting-existing-element)\r\n */\n\n\nvar none = Symbol('none'); // type PickByType<T, U, B = false> = Pick<T, KeysOfType<T, U, B>>;\n\nvar __state = Symbol('__state'); // TODO deprecate\n\n/**\r\n * Creates new state and returns it.\r\n *\r\n * You can create as many global states as you need.\r\n *\r\n * When you the state is not needed anymore,\r\n * it should be destroyed by calling\r\n * `destroy()` method of the returned instance.\r\n * This is necessary for some plugins,\r\n * which allocate native resources,\r\n * like subscription to databases, broadcast channels, etc.\r\n * In most cases, a global state is used during\r\n * whole life time of an application and would not require\r\n * destruction. However, if you have got, for example,\r\n * a catalog of dynamically created and destroyed global states,\r\n * the states should be destroyed as advised above.\r\n *\r\n * @param initial Initial value of the state.\r\n * It can be a value OR a promise,\r\n * which asynchronously resolves to a value,\r\n * OR a function returning a value or a promise.\r\n *\r\n * @typeparam S Type of a value of the state\r\n *\r\n * @returns [State](#state) instance,\r\n * which can be used directly to get and set state value\r\n * outside of React components.\r\n * When you need to use the state in a functional `React` component,\r\n * pass the created state to [useHookstate](#useHookstate) function and\r\n * use the returned result in the component's logic.\r\n */\n\n\nfunction createState(initial) {\n  return hookstate(initial);\n} // TODO deprecated\n\n\nfunction createHookstate(initial) {\n  return hookstate(initial);\n}\n\nfunction hookstate(initial, extension) {\n  var store = createStore(initial);\n  store.activate(extension);\n  var methods = store.toMethods();\n  var devtools = createState[DevToolsID];\n\n  if (devtools) {\n    methods.attach(devtools);\n  }\n\n  return methods.self();\n}\n\nfunction useState(source) {\n  return useHookstate(source);\n} // TODO document\n\n\nfunction extend(e1, e2, e3, e4, e5) {\n  function extended(extensions) {\n    var exts = extensions.map(function (i) {\n      return i();\n    });\n    var onInitCbs = exts.map(function (i) {\n      return i.onInit;\n    }).filter(function (i) {\n      return i;\n    });\n    var onPremergeCbs = exts.map(function (i) {\n      return i.onPremerge;\n    }).filter(function (i) {\n      return i;\n    });\n    var onPresetCbs = exts.map(function (i) {\n      return i.onPreset;\n    }).filter(function (i) {\n      return i;\n    });\n    var onSetCbs = exts.map(function (i) {\n      return i.onSet;\n    }).filter(function (i) {\n      return i;\n    });\n    var onDestroyCbs = exts.map(function (i) {\n      return i.onDestroy;\n    }).filter(function (i) {\n      return i;\n    });\n    var result = {\n      onCreate: function onCreate(instanceFactory, combinedMethods) {\n        for (var _i = 0, exts_1 = exts; _i < exts_1.length; _i++) {\n          var ext = exts_1[_i];\n\n          if (ext.onCreate) {\n            var extMethods = ext.onCreate(instanceFactory, combinedMethods);\n            Object.assign(combinedMethods, extMethods);\n          }\n        }\n\n        return combinedMethods;\n      }\n    };\n\n    if (onInitCbs.length > 0) {\n      result.onInit = function (s, e) {\n        for (var _i = 0, onInitCbs_1 = onInitCbs; _i < onInitCbs_1.length; _i++) {\n          var cb = onInitCbs_1[_i];\n          cb(s, e);\n        }\n      };\n    }\n\n    if (onPremergeCbs.length > 0) {\n      result.onPremerge = function (s, d) {\n        for (var _i = 0, onPremergeCbs_1 = onPremergeCbs; _i < onPremergeCbs_1.length; _i++) {\n          var cb = onPremergeCbs_1[_i];\n          cb(s, d);\n        }\n      };\n    }\n\n    if (onPresetCbs.length > 0) {\n      result.onPreset = function (s, d) {\n        for (var _i = 0, onPresetCbs_1 = onPresetCbs; _i < onPresetCbs_1.length; _i++) {\n          var cb = onPresetCbs_1[_i];\n          cb(s, d);\n        }\n      };\n    }\n\n    if (onSetCbs.length > 0) {\n      result.onSet = function (s, d) {\n        for (var _i = 0, onSetCbs_1 = onSetCbs; _i < onSetCbs_1.length; _i++) {\n          var cb = onSetCbs_1[_i];\n          cb(s, d);\n        }\n      };\n    }\n\n    if (onDestroyCbs.length > 0) {\n      result.onDestroy = function (s) {\n        for (var _i = 0, onDestroyCbs_1 = onDestroyCbs; _i < onDestroyCbs_1.length; _i++) {\n          var cb = onDestroyCbs_1[_i];\n          cb(s);\n        }\n      };\n    }\n\n    return result;\n  }\n\n  return function () {\n    return extended([e1, e2, e3, e4, e5].filter(function (i) {\n      return i;\n    }));\n  };\n}\n\nfunction useHookstate(source, extension) {\n  var parentMethods = Object(source) === source ? source[self] : undefined;\n\n  if (parentMethods) {\n    if (parentMethods.isMounted) {\n      // Scoped state mount\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      var initializer = function initializer() {\n        // warning: this is called twice in react strict mode\n        var store = parentMethods.store;\n\n        var onSetUsedCallback = function onSetUsedCallback() {\n          return setValue_1({\n            store: store,\n            state: state,\n            source: value_1.source // mutable, get the latest from value\n\n          });\n        };\n\n        var state = new StateMethodsImpl(store, parentMethods.path, store.get(parentMethods.path), store.edition, onSetUsedCallback);\n        return {\n          store: store,\n          state: state,\n          source: source\n        };\n      };\n\n      var _a = React.useState(initializer),\n          value_1 = _a[0],\n          setValue_1 = _a[1];\n\n      if (value_1.store !== parentMethods.store || !('source' in value_1)) {\n        throw new StateInvalidUsageError(parentMethods.path, ErrorId.InitStateStoreSwitchover);\n      } // TODO move to a class hide props on prototype level\n      // hide props from development tools\n\n\n      Object.defineProperty(value_1, 'store', {\n        enumerable: false\n      });\n      Object.defineProperty(value_1, 'state', {\n        enumerable: false\n      });\n      Object.defineProperty(value_1, 'source', {\n        enumerable: false\n      });\n      value_1.state.reconstruct(parentMethods.path, value_1.store.get(parentMethods.path), value_1.store.edition, // parent state object has changed its reference object\n      // so the scopped state should change too\n      value_1.source !== source);\n      value_1.source = source; // need to subscribe in sync mode, because\n      // safari delays calling the effect giving priority to timeouts and network events,\n      // which can cause the state update\n\n      parentMethods.subscribe(value_1.state); // no-op if already subscribed\n\n      useIsomorphicLayoutEffect(function () {\n        // warning: in strict mode, effect is called twice\n        // so need to restore subscription and reconstruct the extension\n        // after the first effect unmount callback\n        value_1.state.onMount(); // no-op if already mounted\n\n        parentMethods.subscribe(value_1.state); // no-op if already subscribed\n\n        return function () {\n          value_1.state.onUnmount();\n          parentMethods.unsubscribe(value_1.state);\n        };\n      }, []);\n      var state = value_1.state.self(); // expose property in development tools\n\n      value_1['[hookstate(scoped)]'] = state; // TODO use label here, add core extension to label states\n\n      return state;\n    } else {\n      // Global state mount or destroyed link\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      var initializer = function initializer() {\n        // warning: this is called twice in react strict mode\n        var store = parentMethods.store;\n\n        var onSetUsedCallback = function onSetUsedCallback() {\n          return setValue_2({\n            store: store,\n            state: state,\n            source: value_2.source // mutable, get the latest from value\n\n          });\n        };\n\n        var state = new StateMethodsImpl(store, RootPath, store.get(RootPath), store.edition, onSetUsedCallback);\n        return {\n          store: store,\n          state: state,\n          source: source\n        };\n      };\n\n      var _b = React.useState(initializer),\n          value_2 = _b[0],\n          setValue_2 = _b[1];\n\n      if (value_2.store !== parentMethods.store || !('source' in value_2)) {\n        throw new StateInvalidUsageError(parentMethods.path, ErrorId.InitStateStoreSwitchover);\n      } // hide props from development tools\n\n\n      Object.defineProperty(value_2, 'store', {\n        enumerable: false\n      });\n      Object.defineProperty(value_2, 'state', {\n        enumerable: false\n      });\n      Object.defineProperty(value_2, 'source', {\n        enumerable: false\n      });\n      value_2.state.reconstruct(RootPath, value_2.store.get(RootPath), value_2.store.edition, // parent state object has changed its reference object\n      // so the scopped state should change too\n      value_2.source !== source);\n      value_2.source = source; // need to subscribe in sync mode, because\n      // safari delays calling the effect giving priority to timeouts and network events,\n      // which can cause the state update\n\n      value_2.store.subscribe(value_2.state); // no-op if already subscribed\n\n      useIsomorphicLayoutEffect(function () {\n        // warning: in strict mode, effect is called twice\n        // so need to restore subscription and reconstruct the extension\n        // after the first effect unmount callback\n        value_2.state.onMount(); // no-op if already mounted\n\n        value_2.store.subscribe(value_2.state); // no-op if already subscribed\n\n        return function () {\n          value_2.state.onUnmount();\n          value_2.store.unsubscribe(value_2.state);\n        };\n      }, []);\n      var state = value_2.state.self();\n\n      for (var ind = 0; ind < parentMethods.path.length; ind += 1) {\n        state = state.nested(parentMethods.path[ind]);\n      } // expose property in development tools\n\n\n      value_2['[hookstate(global)]'] = state; // TODO use label here, add core extension to label states\n\n      return state;\n    }\n  } else {\n    // Local state mount\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    var initializer = function initializer() {\n      // warning: this is called twice in react strict mode\n      var store = createStore(source);\n\n      var onSetUsedCallback = function onSetUsedCallback() {\n        return setValue_3({\n          store: store,\n          state: state\n        });\n      };\n\n      var state = new StateMethodsImpl(store, RootPath, store.get(RootPath), store.edition, onSetUsedCallback);\n      return {\n        store: store,\n        state: state\n      };\n    };\n\n    var _c = React.useState(initializer),\n        value_3 = _c[0],\n        setValue_3 = _c[1];\n\n    if ('source' in value_3) {\n      throw new StateInvalidUsageError(RootPath, ErrorId.InitStateStoreSwitchover);\n    } // hide props from development tools\n\n\n    Object.defineProperty(value_3, 'store', {\n      enumerable: false\n    });\n    Object.defineProperty(value_3, 'state', {\n      enumerable: false\n    });\n    value_3.state.reconstruct(RootPath, value_3.store.get(RootPath), value_3.store.edition, false); // need to subscribe in sync mode, because\n    // safari delays calling the effect giving priority to timeouts and network events,\n    // which can cause the state update\n\n    value_3.store.subscribe(value_3.state); // no-op if already subscribed\n    // need to attach the extension straight away\n    // because extension methods are used in render function\n    // and we can not defer it to the effect callback\n\n    value_3.store.activate(extension); // no-op if already attached\n\n    useIsomorphicLayoutEffect(function () {\n      // warning: in strict mode, effect is called twice\n      // so need to restore subscription and reconstruct the extension\n      // after the first effect unmount callback\n      value_3.state.onMount(); // no-op if already mounted\n\n      value_3.store.subscribe(value_3.state); // no-op if already subscribed\n\n      value_3.store.activate(extension); // no-op if already attached\n\n      return function () {\n        value_3.state.onUnmount();\n        value_3.store.unsubscribe(value_3.state);\n        value_3.store.deactivate(); // this will destroy the extensions\n      };\n    }, []);\n    var devtools = useState[DevToolsID];\n\n    if (devtools) {\n      value_3.state.attach(devtools);\n    }\n\n    var state = value_3.state.self(); // expose property in development tools\n\n    value_3['[hookstate(local)]'] = state; // TODO use label here, add core extension to label states\n\n    return state;\n  }\n}\n\nfunction StateFragment(props) {\n  var scoped = useHookstate(props.state, props.extension);\n  return props.suspend && suspend(scoped) || props.children(scoped);\n} // TODO document\n\n\nfunction suspend(state) {\n  var p = state.promise;\n  return p && React.createElement(React.lazy(function () {\n    return p;\n  }));\n} // TODO deprecate\n\n/**\r\n * A plugin which allows to opt-out from usage of Javascript proxies for\r\n * state usage tracking. It is useful for performance tuning.\r\n *\r\n * [Learn more...](https://hookstate.js.org/docs/performance-managed-rendering#downgraded-plugin)\r\n */\n\n\nfunction Downgraded() {\n  return {\n    id: DowngradedID\n  };\n}\n/**\r\n * For plugin developers only.\r\n * Reserved plugin ID for developers tools extension.\r\n *\r\n * @hidden\r\n * @ignore\r\n */\n\n\nvar DevToolsID = Symbol('DevTools');\n/**\r\n * Returns access to the development tools for a given state.\r\n * Development tools are delivered as optional plugins.\r\n * You can activate development tools from `@hookstate/devtools`package,\r\n * for example. If no development tools are activated,\r\n * it returns an instance of dummy tools, which do nothing, when called.\r\n *\r\n * [Learn more...](https://hookstate.js.org/docs/devtools)\r\n *\r\n * @param state A state to relate to the extension.\r\n *\r\n * @returns Interface to interact with the development tools for a given state.\r\n *\r\n * @typeparam S Type of a value of a state\r\n */\n\nfunction DevTools(state) {\n  var plugin = state.attach(DevToolsID);\n\n  if (plugin[0] instanceof Error) {\n    return EmptyDevToolsExtensions;\n  }\n\n  return plugin[0];\n} ///\n/// INTERNAL SYMBOLS (LIBRARY IMPLEMENTATION)\n///\n\n\nvar self = Symbol('self');\nvar EmptyDevToolsExtensions = {\n  label: function label() {},\n  log: function log() {}\n};\nvar ErrorId;\n\n(function (ErrorId) {\n  // TODO document\n  ErrorId[ErrorId[\"StateUsedInDependencyList\"] = 100] = \"StateUsedInDependencyList\";\n  ErrorId[ErrorId[\"InitStateToValueFromState\"] = 101] = \"InitStateToValueFromState\";\n  ErrorId[ErrorId[\"SetStateToValueFromState\"] = 102] = \"SetStateToValueFromState\";\n  ErrorId[ErrorId[\"GetStateWhenPromised\"] = 103] = \"GetStateWhenPromised\";\n  ErrorId[ErrorId[\"SetStateWhenPromised\"] = 104] = \"SetStateWhenPromised\";\n  ErrorId[ErrorId[\"SetStateNestedToPromised\"] = 105] = \"SetStateNestedToPromised\";\n  ErrorId[ErrorId[\"SetStateWhenDestroyed\"] = 106] = \"SetStateWhenDestroyed\";\n  ErrorId[ErrorId[\"ToJson_Value\"] = 108] = \"ToJson_Value\";\n  ErrorId[ErrorId[\"ToJson_State\"] = 109] = \"ToJson_State\"; // TODO document\n\n  ErrorId[ErrorId[\"GetProperty_Function\"] = 110] = \"GetProperty_Function\"; // TODO document\n\n  ErrorId[ErrorId[\"InitStateStoreSwitchover\"] = 111] = \"InitStateStoreSwitchover\";\n  ErrorId[ErrorId[\"GetUnknownPlugin\"] = 120] = \"GetUnknownPlugin\";\n  ErrorId[ErrorId[\"SetProperty_State\"] = 201] = \"SetProperty_State\";\n  ErrorId[ErrorId[\"SetProperty_Value\"] = 202] = \"SetProperty_Value\";\n  ErrorId[ErrorId[\"SetPrototypeOf_State\"] = 203] = \"SetPrototypeOf_State\";\n  ErrorId[ErrorId[\"SetPrototypeOf_Value\"] = 204] = \"SetPrototypeOf_Value\";\n  ErrorId[ErrorId[\"PreventExtensions_State\"] = 205] = \"PreventExtensions_State\";\n  ErrorId[ErrorId[\"PreventExtensions_Value\"] = 206] = \"PreventExtensions_Value\";\n  ErrorId[ErrorId[\"DefineProperty_State\"] = 207] = \"DefineProperty_State\";\n  ErrorId[ErrorId[\"DefineProperty_Value\"] = 208] = \"DefineProperty_Value\";\n  ErrorId[ErrorId[\"DeleteProperty_State\"] = 209] = \"DeleteProperty_State\";\n  ErrorId[ErrorId[\"DeleteProperty_Value\"] = 210] = \"DeleteProperty_Value\";\n  ErrorId[ErrorId[\"Construct_State\"] = 211] = \"Construct_State\";\n  ErrorId[ErrorId[\"Construct_Value\"] = 212] = \"Construct_Value\";\n  ErrorId[ErrorId[\"Apply_State\"] = 213] = \"Apply_State\";\n  ErrorId[ErrorId[\"Apply_Value\"] = 214] = \"Apply_Value\";\n})(ErrorId || (ErrorId = {}));\n\nvar StateInvalidUsageError =\n/** @class */\nfunction (_super) {\n  __extends(StateInvalidUsageError, _super);\n\n  function StateInvalidUsageError(path, id, details) {\n    return _super.call(this, \"Error: HOOKSTATE-\".concat(id, \" [path: /\").concat(path.join('/')).concat(details ? \", details: \".concat(details) : '', \"]. \") + \"See https://hookstate.js.org/docs/exceptions#hookstate-\".concat(id)) || this;\n  }\n\n  return StateInvalidUsageError;\n}(Error); // TODO deprecate\n\n\nvar DowngradedID = Symbol('Downgraded');\nvar SelfMethodsID = Symbol('ProxyMarker');\nvar RootPath = [];\n\nvar Store =\n/** @class */\nfunction () {\n  function Store(_value) {\n    var _this = this;\n\n    this._value = _value; // > 0 means active store, < 0 means destroyed\n    // please note, in react strict mode and hot reload cases\n    // state can be reused, so we should support store resurection\n\n    this.edition = 1;\n    this._subscribers = new Set();\n    this._setSubscribers = new Set();\n    this._destroySubscribers = new Set();\n    this._plugins = new Map();\n\n    if (Object(_value) === _value && configuration.promiseDetector(_value)) {\n      this.setPromised(_value);\n    } else if (_value === none) {\n      this.setPromised(undefined);\n    }\n\n    var onSetUsedStoreStateMethods = function onSetUsedStoreStateMethods() {\n      _this._stateMethods.reconstruct(RootPath, _this.get(RootPath), _this.edition, false);\n    };\n\n    onSetUsedStoreStateMethods[IsUnmounted] = true;\n    this._stateMethods = new StateMethodsImpl(this, RootPath, this.get(RootPath), this.edition, onSetUsedStoreStateMethods);\n    this.subscribe(this._stateMethods);\n  }\n\n  Store.prototype.setPromised = function (promise) {\n    var _this = this;\n\n    this._value = none;\n    this._promiseError = undefined;\n    this._promiseResolver = undefined;\n\n    if (!promise) {\n      this._promise = new Promise(function (resolve) {\n        _this._promiseResolver = resolve;\n      });\n      return;\n    }\n\n    promise = promise.then(function (r) {\n      if (_this._promise === promise) {\n        _this._promise = undefined;\n        _this._promiseError = undefined;\n        _this._promiseResolver === undefined;\n\n        _this.update(_this._stateMethods.self(), _this.set(RootPath, r, undefined));\n      }\n    }).catch(function (err) {\n      if (_this._promise === promise) {\n        _this._promise = undefined;\n        _this._promiseResolver = undefined;\n        _this._promiseError = err;\n        _this.edition += 1;\n        var ad = {\n          path: RootPath\n        };\n\n        _this.update(_this._stateMethods.self(), ad);\n      }\n    });\n    this._promise = promise;\n  };\n\n  Store.prototype.activate = function (extensionFactory) {\n    var _a, _b, _c, _d;\n\n    if (this.edition < 0) {\n      this.edition = -this.edition;\n    }\n\n    if (this._extension === undefined) {\n      this._extension = extensionFactory === null || extensionFactory === void 0 ? void 0 : extensionFactory();\n      this._extensionMethods = (_b = (_a = this._extension) === null || _a === void 0 ? void 0 : _a.onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, this._stateMethods.self(), {}); // this is invoked with all extension methods activated on the state\n\n      (_d = (_c = this._extension) === null || _c === void 0 ? void 0 : _c.onInit) === null || _d === void 0 ? void 0 : _d.call(_c, this._stateMethods.self(), this._extensionMethods || {});\n    }\n  };\n\n  Store.prototype.deactivate = function () {\n    var _a, _b; // TODO remove when plugins are deprecated\n    // old plugins do not support second activation\n\n\n    var params = this._value !== none ? {\n      state: this._value\n    } : {};\n\n    this._destroySubscribers.forEach(function (cb) {\n      return cb(params);\n    });\n\n    if (this._extension) {\n      (_b = (_a = this._extension).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, this._stateMethods.self());\n      delete this._extension;\n      delete this._extensionMethods;\n    }\n\n    if (this.edition > 0) {\n      this.edition = -this.edition;\n    }\n  };\n\n  Object.defineProperty(Store.prototype, \"extension\", {\n    get: function get() {\n      return this._extensionMethods;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Store.prototype, \"promise\", {\n    get: function get() {\n      return this._promise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Store.prototype, \"promiseError\", {\n    get: function get() {\n      return this._promiseError;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Store.prototype.get = function (path) {\n    var result = this._value;\n\n    if (result === none) {\n      return result;\n    }\n\n    path.forEach(function (p) {\n      result = result[p];\n    });\n    return result;\n  };\n\n  Store.prototype.set = function (path, value, mergeValue) {\n    var _a, _b;\n\n    if (this.edition < 0) {\n      // TODO convert to console log\n      throw new StateInvalidUsageError(path, ErrorId.SetStateWhenDestroyed);\n    }\n\n    if (path.length === 0) {\n      // Root value UPDATE case,\n      var onSetArg = {\n        path: path,\n        state: value,\n        value: value,\n        previous: this._value,\n        merged: mergeValue\n      };\n\n      if (value === none) {\n        this.setPromised(undefined);\n        delete onSetArg.value;\n        delete onSetArg.state;\n      } else if (Object(value) === value && configuration.promiseDetector(value)) {\n        this.setPromised(value);\n        value = none;\n        delete onSetArg.value;\n        delete onSetArg.state;\n      } else if (this._promise && !this._promiseResolver) {\n        throw new StateInvalidUsageError(path, ErrorId.SetStateWhenPromised);\n      } else {\n        this._promiseError = undefined;\n      }\n\n      var prevValue = this._value;\n\n      if (prevValue === none) {\n        delete onSetArg.previous;\n      }\n\n      this._value = value;\n      this.afterSet(onSetArg);\n\n      if (prevValue === none && this._value !== none && this._promiseResolver) {\n        this._promise = undefined;\n        this._promiseError = undefined;\n        var resolver = this._promiseResolver;\n        this._promiseResolver === undefined;\n        resolver(this._value);\n      }\n\n      return {\n        path: path\n      };\n    }\n\n    if (Object(value) === value && configuration.promiseDetector(value)) {\n      // TODO this one still can get into the state as nested property, need to check on read instead\n      throw new StateInvalidUsageError(path, ErrorId.SetStateNestedToPromised);\n    }\n\n    var target = this._value;\n\n    for (var i = 0; i < path.length - 1; i += 1) {\n      target = target[path[i]];\n    }\n\n    var p = path[path.length - 1];\n\n    if (p in target) {\n      if (value !== none) {\n        // Property UPDATE case\n        var prevValue = target[p];\n        target[p] = value;\n        this.afterSet({\n          path: path,\n          state: this._value,\n          value: value,\n          previous: prevValue,\n          merged: mergeValue\n        });\n        return {\n          path: path\n        };\n      } else {\n        // Property DELETE case\n        var prevValue = target[p];\n\n        if (Array.isArray(target) && typeof p === 'number') {\n          target.splice(p, 1);\n        } else {\n          delete target[p];\n        }\n\n        this.afterSet({\n          path: path,\n          state: this._value,\n          previous: prevValue,\n          merged: mergeValue\n        }); // if an array of objects is about to loose existing property\n        // we consider it is the whole object is changed\n        // which is identified by upper path\n\n        return {\n          path: path.slice(0, -1),\n          actions: (_a = {}, _a[p] = \"D\", _a)\n        };\n      }\n    }\n\n    if (value !== none) {\n      // Property INSERT case\n      target[p] = value;\n      this.afterSet({\n        path: path,\n        state: this._value,\n        value: value,\n        merged: mergeValue\n      }); // if an array of objects is about to be extended by new property\n      // we consider it is the whole object is changed\n      // which is identified by upper path\n\n      return {\n        path: path.slice(0, -1),\n        actions: (_b = {}, _b[p] = \"I\", _b)\n      };\n    } // Non-existing property DELETE case\n    // no-op\n\n\n    return {\n      path: path\n    };\n  };\n\n  Store.prototype.preset = function (state, value) {\n    var _a, _b;\n\n    (_b = (_a = this._extension) === null || _a === void 0 ? void 0 : _a.onPreset) === null || _b === void 0 ? void 0 : _b.call(_a, state, value);\n  };\n\n  Store.prototype.premerge = function (state, value) {\n    var _a, _b;\n\n    (_b = (_a = this._extension) === null || _a === void 0 ? void 0 : _a.onPremerge) === null || _b === void 0 ? void 0 : _b.call(_a, state, value);\n  };\n\n  Store.prototype.update = function (state, ad) {\n    var _this = this;\n\n    var _a, _b;\n\n    (_b = (_a = this._extension) === null || _a === void 0 ? void 0 : _a.onSet) === null || _b === void 0 ? void 0 : _b.call(_a, state, ad);\n    var actions = new Set(); // check if actions descriptor can be unfolded into a number of individual update actions\n    // this is the case when merge call swaps to properties for example\n    // so we optimize rerendering only these properties\n\n    if (ad.actions && Object.values(ad.actions).findIndex(function (i) {\n      return i !== \"U\";\n    }) === -1) {\n      // all actions are update actions\n      Object.keys(ad.actions).forEach(function (key) {\n        _this._subscribers.forEach(function (s) {\n          return s.onSet({\n            path: ad.path.concat(key)\n          }, actions);\n        });\n      });\n    } else {\n      this._subscribers.forEach(function (s) {\n        return s.onSet(ad, actions);\n      });\n    }\n\n    actions.forEach(function (a) {\n      return a();\n    });\n  };\n\n  Store.prototype.afterSet = function (params) {\n    if (this.edition > 0) {\n      this.edition += 1;\n    }\n\n    if (this.edition < 0) {\n      this.edition -= 1;\n    }\n\n    this._setSubscribers.forEach(function (cb) {\n      return cb(params);\n    });\n  };\n\n  Store.prototype.getPlugin = function (pluginId) {\n    return this._plugins.get(pluginId);\n  };\n\n  Store.prototype.register = function (plugin) {\n    var existingInstance = this._plugins.get(plugin.id);\n\n    if (existingInstance) {\n      return;\n    }\n\n    var pluginCallbacks = plugin.init ? plugin.init(this._stateMethods.self()) : {};\n\n    this._plugins.set(plugin.id, pluginCallbacks);\n\n    if (pluginCallbacks.onSet) {\n      this._setSubscribers.add(function (p) {\n        return pluginCallbacks.onSet(p);\n      });\n    }\n\n    if (pluginCallbacks.onDestroy) {\n      this._destroySubscribers.add(function (p) {\n        return pluginCallbacks.onDestroy(p);\n      });\n    }\n  };\n\n  Store.prototype.toMethods = function () {\n    return this._stateMethods;\n  };\n\n  Store.prototype.subscribe = function (l) {\n    this._subscribers.add(l);\n  };\n\n  Store.prototype.unsubscribe = function (l) {\n    this._subscribers.delete(l);\n  };\n\n  Store.prototype.destroy = function () {\n    this.deactivate();\n  };\n\n  Store.prototype.toJSON = function () {\n    throw new StateInvalidUsageError(RootPath, ErrorId.ToJson_Value);\n  };\n\n  return Store;\n}(); // use symbol property to allow for easier reference finding\n\n\nvar UnusedValue = Symbol('UnusedValue'); // use symbol to mark that a function has no effect anymore\n\nvar IsUnmounted = Symbol('IsUnmounted'); // TODO remove from the docs IE11 support\n\nvar StateMethodsImpl =\n/** @class */\nfunction () {\n  function StateMethodsImpl(store, path, valueSource, valueEdition, onSetUsed) {\n    this.store = store;\n    this.path = path;\n    this.valueSource = valueSource;\n    this.valueEdition = valueEdition;\n    this.onSetUsed = onSetUsed;\n    this.valueUsed = UnusedValue;\n  }\n\n  Object.defineProperty(StateMethodsImpl.prototype, __state, {\n    get: function get() {\n      return [this.get(), this.self()];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateMethodsImpl.prototype.reconstruct = function (path, valueSource, valueEdition, reset) {\n    this.path = path;\n    this.valueSource = valueSource;\n    this.valueEdition = valueEdition;\n    this.valueUsed = UnusedValue;\n\n    if (reset) {\n      delete this.selfUsed;\n      delete this.childrenCreated;\n      delete this.childrenUsedPrevious;\n    } else {\n      this.valueUsedNoProxyPrevious = this.valueUsedNoProxy;\n      this.childrenUsedPrevious = this.childrenUsed;\n    }\n\n    delete this.valueUsedNoProxy;\n    delete this.childrenUsed; // We should not delete subscribers as these are self cleaned up when unmounted\n    // Theoretically it is possible to reconnect subscribers like we done it for \n    // children, but it is easier and more efficient to leave subscribers to have independent lifecycle\n    // If we delete subscribers here, scoped states wrapped in React.memo\n    // will lose state change propagation and rerendering for scopped states\n    // delete this.subscribers;\n  };\n\n  StateMethodsImpl.prototype.reconnect = function () {\n    // Mark it's as used, because it is used in a dependency list\n    // (we are making it's value used implicitly, so rerender is triggered).\n    // Otherwise, no rerender => no effects running, even when a value is changed.\n    // This is marking the state used a bit more than it might be really used\n    // in the effect callback. More optimized / precise implementation would be\n    // to remember useSelf as previous (similar to childrenUsed),\n    // but it is a lot more complicated and the benefit is not worth the complexity.\n    // So, mark it used.\n    // We also using it without proxy if it wass used without proxy during the\n    // previous render, because otherwise children usage might be not traced completely\n    // and so will not result in renreder if children are updated.\n    // This is covered by some tests, but there are so many possible corner cases...\n    this.get({\n      __internalAllowPromised: true,\n      noproxy: this.valueUsedNoProxyPrevious\n    });\n    this.childrenUsed = _assign(_assign({}, this.childrenUsedPrevious), this.childrenUsed);\n  };\n\n  StateMethodsImpl.prototype.getUntracked = function (__internalAllowPromised) {\n    if (this.valueEdition !== this.store.edition) {\n      this.valueSource = this.store.get(this.path);\n      this.valueEdition = this.store.edition;\n\n      if (this.valueUsed !== UnusedValue) {\n        this.valueUsed = UnusedValue;\n        this.get({\n          __internalAllowPromised: true\n        }); // renew cache to keep it marked used\n      }\n    }\n\n    if (__internalAllowPromised) {\n      return this.valueSource;\n    }\n\n    if (this.store.promiseError) {\n      throw this.store.promiseError;\n    }\n\n    if (this.store.promise) {\n      throw new StateInvalidUsageError(this.path, ErrorId.GetStateWhenPromised);\n    }\n\n    return this.valueSource;\n  };\n\n  StateMethodsImpl.prototype.get = function (options) {\n    var _a;\n\n    var valueSource = this.getUntracked(options === null || options === void 0 ? void 0 : options.__internalAllowPromised);\n\n    if (options === null || options === void 0 ? void 0 : options.stealth) {\n      return valueSource;\n    }\n\n    if (this.valueUsed === UnusedValue) {\n      if (Array.isArray(valueSource)) {\n        this.valueUsed = this.valueArrayImpl(valueSource);\n      } else if (Object(valueSource) === valueSource) {\n        if (((_a = valueSource.constructor) === null || _a === void 0 ? void 0 : _a.name) === \"Object\") {\n          this.valueUsed = this.valueObjectImpl(valueSource);\n        } else {\n          // any other object except Object, for example Date\n          this.valueUsedNoProxy = true;\n          this.valueUsed = valueSource;\n        }\n      } else {\n        this.valueUsed = valueSource;\n      }\n    }\n\n    if (options === null || options === void 0 ? void 0 : options.noproxy) {\n      this.valueUsedNoProxy = true;\n      return valueSource;\n    }\n\n    return this.valueUsed;\n  };\n\n  Object.defineProperty(StateMethodsImpl.prototype, \"value\", {\n    get: function get() {\n      // various tools, including react dev tools and webpack import\n      // inspect an object and it's properties\n      // so these should not throw\n      // return this.get({ __internalAllowPromised: true })\n      return this.get();\n    },\n    enumerable: false,\n    configurable: true\n  }); // TODO remove when attach is removed\n\n  StateMethodsImpl.prototype.setUntracked = function (newValue, mergeValue) {\n    var r = this.setUntrackedV4(newValue, mergeValue);\n\n    if (r) {\n      return [r.path];\n    }\n\n    return [];\n  }; // TODO remove mergeValue when attach is removed\n\n\n  StateMethodsImpl.prototype.setUntrackedV4 = function (newValue, mergeValue) {\n    if (typeof newValue === 'function') {\n      newValue = newValue(this.getUntracked());\n    }\n\n    this.store.preset(this.self(), newValue);\n\n    if (Object(newValue) === newValue && newValue[SelfMethodsID]) {\n      // TODO check on read instead as it might escape as nested on set anyway\n      throw new StateInvalidUsageError(this.path, ErrorId.SetStateToValueFromState);\n    }\n\n    if (newValue !== Object(newValue) && newValue === this.getUntracked(true)) {\n      // this is primitive value and has not changed\n      // so skip this set call as it does not make an effect\n      return null;\n    }\n\n    return this.store.set(this.path, newValue, mergeValue);\n  };\n\n  StateMethodsImpl.prototype.set = function (newValue) {\n    var ad = this.setUntrackedV4(newValue);\n\n    if (ad) {\n      this.store.update(this.self(), ad);\n    }\n  };\n\n  StateMethodsImpl.prototype.mergeUntracked = function (sourceValue) {\n    var r = this.mergeUntrackedV4(sourceValue);\n\n    if (r) {\n      return [r.path];\n    }\n\n    return [];\n  };\n\n  StateMethodsImpl.prototype.mergeUntrackedV4 = function (sourceValue) {\n    var currentValue = this.getUntracked();\n\n    if (typeof sourceValue === 'function') {\n      sourceValue = sourceValue(currentValue);\n    }\n\n    this.store.premerge(this.self(), sourceValue);\n\n    if (Array.isArray(currentValue)) {\n      if (Array.isArray(sourceValue)) {\n        var ad_1 = {\n          path: this.path,\n          actions: {}\n        };\n        sourceValue.forEach(function (e, i) {\n          ad_1.actions[currentValue.push(e) - 1] = \"I\";\n        });\n\n        if (Object.keys(ad_1.actions).length > 0) {\n          this.setUntrackedV4(currentValue, sourceValue);\n          return ad_1;\n        }\n\n        return null;\n      } else {\n        var ad_2 = {\n          path: this.path,\n          actions: {}\n        };\n        var deletedIndexes_1 = [];\n        Object.keys(sourceValue).sort().forEach(function (i) {\n          var index = Number(i);\n          var newPropValue = sourceValue[index];\n\n          if (newPropValue === none) {\n            ad_2.actions[index] = \"D\";\n            deletedIndexes_1.push(index);\n          } else {\n            if (index in currentValue) {\n              ad_2.actions[index] = \"U\";\n            } else {\n              ad_2.actions[index] = \"I\";\n            }\n\n            currentValue[index] = newPropValue;\n          }\n        }); // indexes are ascending sorted as per above\n        // so, delete one by one from the end\n        // this way index positions do not change\n\n        deletedIndexes_1.reverse().forEach(function (p) {\n          currentValue.splice(p, 1);\n        });\n\n        if (Object.keys(ad_2.actions).length > 0) {\n          this.setUntrackedV4(currentValue, sourceValue);\n          return ad_2;\n        }\n\n        return null;\n      }\n    } else if (Object(currentValue) === currentValue) {\n      var ad_3 = {\n        path: this.path,\n        actions: {}\n      };\n      Object.keys(sourceValue).forEach(function (key) {\n        var newPropValue = sourceValue[key];\n\n        if (newPropValue === none) {\n          ad_3.actions[key] = \"D\";\n          delete currentValue[key];\n        } else {\n          if (key in currentValue) {\n            ad_3.actions[key] = \"U\";\n          } else {\n            ad_3.actions[key] = \"I\";\n          }\n\n          currentValue[key] = newPropValue;\n        }\n      });\n\n      if (Object.keys(ad_3.actions).length > 0) {\n        this.setUntrackedV4(currentValue, sourceValue);\n        return ad_3;\n      }\n\n      return null;\n    } else if (typeof currentValue === 'string') {\n      return this.setUntrackedV4(currentValue + String(sourceValue), sourceValue);\n    } else {\n      return this.setUntrackedV4(sourceValue);\n    }\n  };\n\n  StateMethodsImpl.prototype.merge = function (sourceValue) {\n    var r = this.mergeUntrackedV4(sourceValue);\n\n    if (r) {\n      this.store.update(this.self(), r);\n    }\n  };\n\n  StateMethodsImpl.prototype.nested = function (key) {\n    return this.child(key).self();\n  };\n\n  StateMethodsImpl.prototype.rerender = function (paths) {\n    for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {\n      var path = paths_1[_i];\n      this.store.update(this.self(), {\n        path: path\n      });\n    }\n  };\n\n  StateMethodsImpl.prototype.destroy = function () {\n    this.store.destroy();\n  };\n\n  StateMethodsImpl.prototype.subscribe = function (l) {\n    if (this.subscribers === undefined) {\n      this.subscribers = new Set();\n    }\n\n    this.subscribers.add(l);\n  };\n\n  StateMethodsImpl.prototype.unsubscribe = function (l) {\n    if (this.subscribers) {\n      this.subscribers.delete(l);\n    }\n  };\n\n  Object.defineProperty(StateMethodsImpl.prototype, \"isMounted\", {\n    get: function get() {\n      return !this.onSetUsed[IsUnmounted];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateMethodsImpl.prototype.onMount = function () {\n    delete this.onSetUsed[IsUnmounted];\n  };\n\n  StateMethodsImpl.prototype.onUnmount = function () {\n    this.onSetUsed[IsUnmounted] = true;\n  };\n\n  StateMethodsImpl.prototype.onSet = function (ad, actions) {\n    var _this = this;\n\n    var update = function update() {\n      var _a;\n\n      var isAffected = false;\n\n      if (_this.valueUsedNoProxy // TODO this condition becomes redundant when Downgraded plugins is deleted\n      && _this.valueUsed !== UnusedValue) {\n        actions.add(_this.onSetUsed);\n        delete _this.selfUsed;\n        isAffected = true;\n      }\n\n      var path = ad.path;\n      var nextChildKey = path[_this.path.length];\n\n      if (nextChildKey === undefined) {\n        // There is no next child to dive into\n        // So it is this one which was updated\n        if (_this.valueUsed !== UnusedValue) {\n          actions.add(_this.onSetUsed);\n          delete _this.selfUsed;\n          delete _this.childrenUsed;\n\n          if (ad.actions && _this.childrenCreated) {\n            // TODO add automated unit tests for this part\n            if (Array.isArray(_this.valueSource) && Object.values(ad.actions).includes(\"D\")) {\n              // this is an array and some elements were removed\n              // so invalidate cache for all children after the first deleted\n              var firstDeletedIndex = Object.keys(ad.actions).map(function (i) {\n                return Number(i);\n              }).sort().find(function (i) {\n                var _a;\n\n                return ((_a = ad.actions) === null || _a === void 0 ? void 0 : _a[i]) === \"D\";\n              });\n\n              for (var childKey in _this.childrenCreated) {\n                if (Number(childKey) >= firstDeletedIndex || childKey in ad.actions) {\n                  delete _this.childrenCreated[childKey];\n                }\n              }\n            } else {\n              for (var childKey in ad.actions) {\n                delete _this.childrenCreated[childKey];\n              }\n            }\n          } else {\n            delete _this.childrenCreated;\n          }\n\n          return true;\n        }\n      } else {\n        var nextChild = (_a = _this.childrenUsed) === null || _a === void 0 ? void 0 : _a[nextChildKey];\n\n        if (nextChild && nextChild.onSet(ad, actions)) {\n          delete _this.selfUsed;\n          return true;\n        }\n      }\n\n      return isAffected;\n    };\n\n    var updated = update();\n\n    if (!updated && this.subscribers !== undefined) {\n      this.subscribers.forEach(function (s) {\n        if (s.onSet(ad, actions)) {\n          delete _this.selfUsed;\n        }\n      });\n    }\n\n    return updated;\n  };\n\n  Object.defineProperty(StateMethodsImpl.prototype, \"keys\", {\n    get: function get() {\n      var value = this.get();\n\n      if (Array.isArray(value)) {\n        return Object.keys(value).map(function (i) {\n          return Number(i);\n        }).filter(function (i) {\n          return Number.isInteger(i);\n        });\n      }\n\n      if (Object(value) === value) {\n        return Object.keys(value);\n      }\n\n      return undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateMethodsImpl.prototype.child = function (key) {\n    this.childrenUsed = this.childrenUsed || {};\n    var cachedChild = this.childrenUsed.hasOwnProperty(key) && this.childrenUsed[key];\n\n    if (cachedChild) {\n      return cachedChild;\n    }\n\n    var valueSource = this.valueSource[key];\n\n    if (typeof valueSource === 'function') {\n      // hitting a method of a custom type, should be no-op\n      throw new StateInvalidUsageError(this.path, ErrorId.GetProperty_Function);\n    }\n\n    this.childrenCreated = this.childrenCreated || {};\n    var child = this.childrenCreated[key];\n    var r;\n\n    if (child) {\n      child.reconstruct(this.path.concat(key), valueSource, this.valueEdition, false);\n      r = child;\n    } else {\n      r = new StateMethodsImpl(this.store, this.path.concat(key), valueSource, this.valueEdition, this.onSetUsed);\n      this.childrenCreated[key] = r;\n    }\n\n    if (this.valueUsedNoProxy) {\n      // TODO this is redundant when Downgraded plugin is deleted\n      r.valueUsedNoProxy = true;\n    }\n\n    this.childrenUsed[key] = r;\n    return r;\n  };\n\n  StateMethodsImpl.prototype.valueArrayImpl = function (currentValue) {\n    var _this = this;\n\n    return proxyWrap(this.path, currentValue, function () {\n      return currentValue;\n    }, function (target, key) {\n      if (key === 'length') {\n        return target.length;\n      }\n\n      if (key in Array.prototype) {\n        return Array.prototype[key];\n      }\n\n      if (key === SelfMethodsID) {\n        return _this;\n      }\n\n      if (typeof key === 'symbol') {\n        // allow clients to associate hidden cache with state values\n        return target[key];\n      }\n\n      var index = Number(key);\n\n      if (!Number.isInteger(index)) {\n        return undefined;\n      }\n\n      return _this.child(index).get();\n    }, function (target, key, value) {\n      if (typeof key === 'symbol') {\n        // allow clients to associate hidden cache with state values\n        target[key] = value;\n        return true;\n      }\n\n      throw new StateInvalidUsageError(_this.path, ErrorId.SetProperty_Value);\n    }, true);\n  };\n\n  StateMethodsImpl.prototype.valueObjectImpl = function (currentValue) {\n    var _this = this;\n\n    return proxyWrap(this.path, currentValue, function () {\n      return currentValue;\n    }, function (target, key) {\n      if (key in Object.prototype) {\n        return Object.prototype[key];\n      }\n\n      if (key === SelfMethodsID) {\n        return _this;\n      }\n\n      if (typeof key === 'symbol') {\n        // allow clients to associate hidden cache with state values\n        return target[key];\n      }\n\n      return _this.child(key).get();\n    }, function (target, key, value) {\n      if (typeof key === 'symbol') {\n        // allow clients to associate hidden cache with state values\n        target[key] = value;\n        return true;\n      }\n\n      throw new StateInvalidUsageError(_this.path, ErrorId.SetProperty_Value);\n    }, true);\n  };\n\n  StateMethodsImpl.prototype.self = function () {\n    var _this = this;\n\n    if (this.selfUsed) {\n      return this.selfUsed;\n    }\n\n    var getter = function getter(_, key) {\n      if (key === self) {\n        return _this;\n      }\n\n      if (typeof key === 'symbol') {\n        return undefined;\n      }\n\n      if (key === 'toJSON') {\n        throw new StateInvalidUsageError(_this.path, ErrorId.ToJson_State);\n      }\n\n      var nestedGetter = function nestedGetter(prop) {\n        var currentValue = _this.get({\n          __internalAllowPromised: prop === '$$typeof' || prop === 'constructor'\n        });\n\n        if (prop in Object.prototype) {\n          // Mark it used entirely, so changes to the value\n          // invalidate and rerender results for Object.prototype.toString(),\n          // for example.\n          // We check for Object prototype functions\n          // even for primitive values, because primitive values still\n          // can have object methods.\n          return Object.prototype[prop];\n        }\n\n        if ( // if currentValue is primitive type\n        Object(currentValue) !== currentValue && // if promised, it will be none\n        currentValue !== none) {\n          // This was an error case, but various tools like webpack bundler\n          // and react dev tools attempt to get props out of non-null object,\n          // so this was changed to return just undefined for any property request\n          // as there is no way to fix 3rd party tools.\n          // Logging a warning to console is also not an option\n          // as it pollutes console for legitimate apps on app start app.\n          // Ref: https://github.com/avkonst/hookstate/issues/125\n          return undefined;\n        }\n\n        if (Array.isArray(currentValue)) {\n          if (prop === 'length') {\n            return currentValue.length;\n          }\n\n          if (prop in Array.prototype) {\n            return Array.prototype[prop];\n          }\n\n          var index = Number(prop);\n\n          if (!Number.isInteger(index)) {\n            return undefined;\n          }\n\n          return _this.nested(index);\n        }\n\n        return _this.nested(prop.toString());\n      };\n\n      switch (key) {\n        case 'path':\n          return _this.path;\n\n        case 'keys':\n          return _this.keys;\n\n        case 'value':\n          return _this.value;\n\n        case 'ornull':\n          return _this.ornull;\n\n        case 'promised':\n          return _this.promised;\n\n        case 'promise':\n          return _this.promise;\n\n        case 'error':\n          return _this.error;\n\n        case 'get':\n          return function (opts) {\n            return _this.get(opts);\n          };\n\n        case 'set':\n          return function (p) {\n            return _this.set(p);\n          };\n\n        case 'merge':\n          return function (p) {\n            return _this.merge(p);\n          };\n\n        case 'nested':\n          return function (p) {\n            return nestedGetter(p);\n          };\n\n        case 'attach':\n          return function (p) {\n            return _this.attach(p);\n          };\n\n        case 'destroy':\n          // TODO move destroy to the state, otherwise State type hides this well existing property\n          // TODO when depreacted update hookstate-106 exception docs\n          return function () {\n            return _this.destroy();\n          };\n\n        default:\n          // check if extension method\n          var ext = _this.store.extension;\n\n          if (ext && key in ext) {\n            return ext[key](_this.self());\n          } // otherwise nested child\n\n\n          return nestedGetter(key);\n      }\n    };\n\n    this.selfUsed = proxyWrap(this.path, this.valueSource, function (opts) {\n      return _this.get({\n        __internalAllowPromised: true,\n        stealth: opts === null || opts === void 0 ? void 0 : opts.stealth\n      });\n    }, getter, function (_, key, value) {\n      throw new StateInvalidUsageError(_this.path, ErrorId.SetProperty_State);\n    }, false);\n    return this.selfUsed;\n  };\n\n  Object.defineProperty(StateMethodsImpl.prototype, \"promised\", {\n    get: function get() {\n      this.get({\n        __internalAllowPromised: true\n      }); // marks used\n\n      return !!this.store.promise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateMethodsImpl.prototype, \"promise\", {\n    get: function get() {\n      var _this = this;\n\n      var _a;\n\n      this.get({\n        __internalAllowPromised: true\n      }); // marks used\n\n      return (_a = this.store.promise) === null || _a === void 0 ? void 0 : _a.then(function (_) {\n        return _this.self();\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateMethodsImpl.prototype, \"error\", {\n    get: function get() {\n      this.get({\n        __internalAllowPromised: !!this.store.promiseError\n      }); // marks used\n\n      return this.store.promiseError;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(StateMethodsImpl.prototype, \"ornull\", {\n    get: function get() {\n      var value = this.get();\n\n      if (value === null || value === undefined) {\n        return value;\n      }\n\n      return this.self();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StateMethodsImpl.prototype.attach = function (p) {\n    if (typeof p === 'function') {\n      var pluginMeta = p();\n\n      if (pluginMeta.id === DowngradedID) {\n        this.valueUsedNoProxy = true;\n\n        if (this.valueUsed !== UnusedValue) {\n          var currentValue = this.getUntracked(true);\n          this.valueUsed = currentValue;\n        }\n\n        return this.self();\n      }\n\n      this.store.register(pluginMeta);\n      return this.self();\n    } else {\n      return [this.store.getPlugin(p) || new StateInvalidUsageError(this.path, ErrorId.GetUnknownPlugin, p.toString()), this];\n    }\n  };\n\n  return StateMethodsImpl;\n}();\n\nfunction proxyWrap(path, // tslint:disable-next-line: no-any\ntargetBootstrap, // tslint:disable-next-line: no-any\ntargetGetter, // tslint:disable-next-line: no-any\npropertyGetter, // tslint:disable-next-line: no-any\npropertySetter, isValueProxy) {\n  var onInvalidUsage = function onInvalidUsage(op) {\n    throw new StateInvalidUsageError(path, op);\n  };\n\n  if (Object(targetBootstrap) !== targetBootstrap) {\n    targetBootstrap = {};\n  }\n\n  return new Proxy(targetBootstrap, {\n    getPrototypeOf: function getPrototypeOf(_target) {\n      // should satisfy the invariants:\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getPrototypeOf#Invariants\n      var targetReal = targetGetter();\n\n      if (targetReal === undefined || targetReal === null) {\n        return null;\n      }\n\n      if (targetReal === none) {\n        return Object.getPrototypeOf(new Promise(function () {}));\n      }\n\n      return Object.getPrototypeOf(targetReal);\n    },\n    setPrototypeOf: function setPrototypeOf(_target, v) {\n      return onInvalidUsage(isValueProxy ? ErrorId.SetPrototypeOf_State : ErrorId.SetPrototypeOf_Value);\n    },\n    isExtensible: function isExtensible(_target) {\n      // should satisfy the invariants:\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/isExtensible#Invariants\n      return true; // required to satisfy the invariants of the getPrototypeOf\n      // return Object.isExtensible(target);\n    },\n    preventExtensions: function preventExtensions(_target) {\n      return onInvalidUsage(isValueProxy ? ErrorId.PreventExtensions_State : ErrorId.PreventExtensions_Value);\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_target, p) {\n      var targetReal = targetGetter();\n\n      if (Object(targetReal) === targetReal) {\n        var origin_1 = Object.getOwnPropertyDescriptor(targetReal, p);\n\n        if (Array.isArray(targetReal) && p in Array.prototype) {\n          return origin_1;\n        }\n\n        return origin_1 && {\n          // should be configurable as may not exist on proxy target\n          configurable: true,\n          enumerable: origin_1.enumerable,\n          get: function get() {\n            return propertyGetter(targetReal, p);\n          },\n          set: undefined\n        };\n      }\n\n      if (isValueProxy || targetReal === none) {\n        return undefined;\n      }\n\n      if (p === 'value') {\n        return {\n          // should be configurable as does not exist on proxy target\n          configurable: true,\n          enumerable: true,\n          get: function get() {\n            return targetGetter({\n              stealth: true\n            });\n          },\n          set: undefined\n        };\n      }\n\n      if (p === 'path') {\n        return {\n          // should be configurable as does not exist on proxy target\n          configurable: true,\n          enumerable: true,\n          get: function get() {\n            return path;\n          },\n          set: undefined\n        };\n      }\n\n      return undefined;\n    },\n    has: function has(_target, p) {\n      if (typeof p === 'symbol') {\n        return false;\n      }\n\n      var targetReal = targetGetter();\n\n      if (Object(targetReal) === targetReal) {\n        return p in targetReal;\n      }\n\n      if (isValueProxy || targetReal === none) {\n        return false;\n      }\n\n      return p === 'value' || p === 'path';\n    },\n    get: propertyGetter,\n    set: propertySetter,\n    deleteProperty: function deleteProperty(_target, p) {\n      return onInvalidUsage(isValueProxy ? ErrorId.DeleteProperty_State : ErrorId.DeleteProperty_Value);\n    },\n    defineProperty: function defineProperty(_target, p, attributes) {\n      return onInvalidUsage(isValueProxy ? ErrorId.DefineProperty_State : ErrorId.DefineProperty_Value);\n    },\n    ownKeys: function ownKeys(_target) {\n      var targetReal = targetGetter();\n\n      if (Array.isArray(targetReal)) {\n        if (_target.length === undefined) {\n          // an object turned into an array now\n          // inject length property now as it is defined on the array\n          // to enable getOwnPropertyDescriptor for length not throw\n          Object.defineProperty(targetBootstrap, 'length', {\n            value: 0,\n            writable: true,\n            enumerable: false,\n            configurable: false\n          });\n        }\n      }\n\n      if (Object(targetReal) === targetReal) {\n        return Object.getOwnPropertyNames(targetReal);\n      }\n\n      if (isValueProxy || targetReal === none) {\n        return [];\n      }\n\n      return ['value', 'path'];\n    },\n    apply: function apply(_target, thisArg, argArray) {\n      return onInvalidUsage(isValueProxy ? ErrorId.Apply_State : ErrorId.Apply_Value);\n    },\n    construct: function construct(_target, argArray, newTarget) {\n      return onInvalidUsage(isValueProxy ? ErrorId.Construct_State : ErrorId.Construct_Value);\n    }\n  });\n}\n\nfunction createStore(initial) {\n  var initialValue = initial;\n\n  if (typeof initial === 'function') {\n    initialValue = initial();\n  }\n\n  if (Object(initialValue) === initialValue && initialValue[SelfMethodsID]) {\n    throw new StateInvalidUsageError(RootPath, ErrorId.InitStateToValueFromState);\n  }\n\n  return new Store(initialValue);\n}\n\nvar configuration = {\n  interceptDependencyListsMode: 'always',\n  // TODO this does not always work, so it is better if it is set by the app explictly. Document this\n  isDevelopmentMode: typeof process === 'object' && typeof process.env === 'object' && process.env.NODE_ENV === 'development',\n  promiseDetector: function promiseDetector(p) {\n    return Promise.resolve(p) === p;\n  },\n  hiddenInterceptDependencyListsModeDebug: false\n}; // TODO document\n\nfunction configure(config) {\n  var _a, _b, _c;\n\n  configuration = {\n    interceptDependencyListsMode: (_a = config.interceptDependencyListsMode) !== null && _a !== void 0 ? _a : configuration.interceptDependencyListsMode,\n    isDevelopmentMode: (_b = config.isDevelopmentMode) !== null && _b !== void 0 ? _b : configuration.isDevelopmentMode,\n    promiseDetector: (_c = config.promiseDetector) !== null && _c !== void 0 ? _c : configuration.promiseDetector,\n    hiddenInterceptDependencyListsModeDebug: false\n  };\n  interceptReactHooks(); // not really required, but for safety\n\n  if (configuration.interceptDependencyListsMode === 'never') {\n    configuration.hiddenInterceptDependencyListsModeDebug = false;\n    React['useEffect'] = React['useEffect'] && useEffectOrigin;\n    React['useLayoutEffect'] = React['useLayoutEffect'] && useLayoutEffectOrigin;\n    React['useInsertionEffect'] = React['useInsertionEffect'] && useInsertionEffectOrigin;\n    React['useImperativeHandle'] = React['useImperativeHandle'] && useImperativeHandleOrigin;\n    React['useMemo'] = React['useMemo'] && useMemoOrigin;\n    React['useCallback'] = React['useCallback'] && useCallbackOrigin; // the following does not make an effect as memo calls happen on module load\n    // so it is always set to memoIntercept\n\n    React['memo'] = React['memo'] && memoOrigin;\n  } else {\n    // do not intercept if a hook is not defined in React\n    // otherwise, it will enable 3rd party libs thinking the react runs at version 18\n    React['useEffect'] = React['useEffect'] && useEffectIntercept;\n    React['useLayoutEffect'] = React['useLayoutEffect'] && useLayoutEffectIntercept;\n    React['useInsertionEffect'] = React['useLayoutEffect'] && useInsertionEffectIntercept;\n    React['useImperativeHandle'] = React['useImperativeHandle'] && useImperativeHandleIntercept;\n    React['useMemo'] = React['useMemo'] && useMemoIntercept;\n    React['useCallback'] = React['useCallback'] && useCallbackIntercept; // the following does not make an effect as memo calls happen on module load\n    // so it is always set to memoIntercept\n\n    React['memo'] = React['memo'] && memoIntercept;\n\n    if (configuration.interceptDependencyListsMode === 'development' && configuration.isDevelopmentMode) {\n      configuration.hiddenInterceptDependencyListsModeDebug = true;\n    }\n  }\n}\n\nfunction reconnectDependencies(deps, fromIntercept) {\n  for (var _i = 0, _a = deps || []; _i < _a.length; _i++) {\n    var i = _a[_i];\n\n    if (i === Object(i)) {\n      var state = i[self];\n\n      if (state) {\n        if (fromIntercept && configuration.hiddenInterceptDependencyListsModeDebug) {\n          // TODO document this exception\n          throw new StateInvalidUsageError(state.path, ErrorId.StateUsedInDependencyList);\n        }\n\n        state.reconnect();\n      }\n    }\n  }\n\n  return deps;\n}\n\nvar useEffectOrigin;\n\nfunction useHookstateEffect(effect, deps) {\n  reconnectDependencies(deps);\n  return useEffectOrigin(effect, deps);\n}\n\nfunction useEffectIntercept(effect, deps) {\n  reconnectDependencies(deps, true);\n  return useEffectOrigin(effect, deps);\n}\n\nvar useLayoutEffectOrigin;\n\nfunction useHookstateLayoutEffect(effect, deps) {\n  reconnectDependencies(deps);\n  return useLayoutEffectOrigin(effect, deps);\n}\n\nfunction useLayoutEffectIntercept(effect, deps) {\n  reconnectDependencies(deps, true);\n  return useLayoutEffectOrigin(effect, deps);\n}\n\nvar useInsertionEffectOrigin;\n\nfunction useHookstateInsertionEffect(effect, deps) {\n  reconnectDependencies(deps);\n  return useInsertionEffectOrigin(effect, deps);\n}\n\nfunction useInsertionEffectIntercept(effect, deps) {\n  reconnectDependencies(deps, true);\n  return useInsertionEffectOrigin(effect, deps);\n}\n\nvar useImperativeHandleOrigin;\n\nfunction useHookstateImperativeHandle(ref, init, deps) {\n  reconnectDependencies(deps);\n  return useImperativeHandleOrigin(ref, init, deps);\n}\n\nfunction useImperativeHandleIntercept(ref, init, deps) {\n  reconnectDependencies(deps, true);\n  return useImperativeHandleOrigin(ref, init, deps);\n}\n\nvar useMemoOrigin;\n\nfunction useHookstateMemo(factory, deps) {\n  reconnectDependencies(deps);\n  return useMemoOrigin(factory, deps);\n}\n\nfunction useMemoIntercept(factory, deps) {\n  reconnectDependencies(deps, true);\n  return useMemoOrigin(factory, deps);\n}\n\nvar useCallbackOrigin;\n\nfunction useHookstateCallback(callback, deps) {\n  reconnectDependencies(deps);\n  return useCallbackOrigin(callback, deps);\n}\n\nfunction useCallbackIntercept(callback, deps) {\n  reconnectDependencies(deps, true);\n  return useCallbackOrigin(callback, deps);\n}\n\nvar memoOrigin;\n\nfunction hookstateMemo(Component, propsAreEqual) {\n  return memoOrigin(Component, function (prevProps, nextProps) {\n    reconnectDependencies(Object.keys(nextProps).map(function (i) {\n      return nextProps[i];\n    }));\n    return (propsAreEqual || shallowEqual)(prevProps, nextProps);\n  });\n}\n\nfunction memoIntercept(Component, propsAreEqual) {\n  return memoOrigin(Component, function (prevProps, nextProps) {\n    reconnectDependencies(Object.keys(nextProps).map(function (i) {\n      return nextProps[i];\n    }), true);\n    return (propsAreEqual || shallowEqual)(prevProps, nextProps);\n  });\n}\n\nfunction interceptReactHooks() {\n  if (!useEffectOrigin && React['useEffect']) {\n    useEffectOrigin = React['useEffect'];\n    React['useEffect'] = useEffectIntercept;\n  }\n\n  if (!useLayoutEffectOrigin && React['useLayoutEffect']) {\n    useLayoutEffectOrigin = React['useLayoutEffect'];\n    React['useLayoutEffect'] = useLayoutEffectIntercept;\n  }\n\n  if (!useInsertionEffectOrigin && React['useInsertionEffect']) {\n    useInsertionEffectOrigin = React['useInsertionEffect'];\n    React['useInsertionEffect'] = useInsertionEffectIntercept;\n  }\n\n  if (!useImperativeHandleOrigin && React['useImperativeHandle']) {\n    useImperativeHandleOrigin = React['useImperativeHandle'];\n    React['useImperativeHandle'] = useImperativeHandleIntercept;\n  }\n\n  if (!useMemoOrigin && React['useMemo']) {\n    useMemoOrigin = React['useMemo'];\n    React['useMemo'] = useMemoIntercept;\n  }\n\n  if (!useCallbackOrigin && React['useCallback']) {\n    useCallbackOrigin = React['useCallback'];\n    React['useCallback'] = useCallbackIntercept;\n  }\n\n  if (!memoOrigin && React['memo']) {\n    memoOrigin = React['memo'];\n    React['memo'] = memoIntercept;\n  }\n}\n\ninterceptReactHooks(); // TODO defer invoking it until state is created, so the configure had a chance to set it up first\n// Do not try to use useLayoutEffect if DOM not available (SSR)\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffectOrigin : useEffectOrigin;\nexport { DevTools, DevToolsID, Downgraded, StateFragment, __state, configure, createHookstate, createState, extend, hookstate, hookstateMemo, none, suspend, useHookstate, useHookstateCallback, useHookstateEffect, useHookstateImperativeHandle, useHookstateInsertionEffect, useHookstateLayoutEffect, useHookstateMemo, useMemoIntercept, useState };","map":null,"metadata":{},"sourceType":"module"}